<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³è¯†åˆ«ä¿®å¤æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .warning { background: #fff3cd; color: #856404; }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ è¯­éŸ³è¯†åˆ«ä¿®å¤éªŒè¯</h1>
        
        <div id="status" class="status info">
            å‡†å¤‡å°±ç»ª - ç‚¹å‡»å¼€å§‹æµ‹è¯•è¯­éŸ³è¯†åˆ«åŠŸèƒ½
        </div>

        <div>
            <button id="testBtn" onclick="testVoiceRecognition()">å¼€å§‹è¯­éŸ³è¯†åˆ«æµ‹è¯•</button>
            <button id="stopBtn" onclick="stopTest()" disabled>åœæ­¢æµ‹è¯•</button>
            <button onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
        </div>

        <h3>ğŸ“‹ æµ‹è¯•æ—¥å¿—</h3>
        <div id="log" class="log">ç­‰å¾…æµ‹è¯•å¼€å§‹...</div>

        <h3>ğŸ“Š æµ‹è¯•ç»“æœ</h3>
        <div id="results">
            <p><strong>éŸ³é¢‘æ ¼å¼æ”¯æŒ:</strong> <span id="mimeType">æ£€æµ‹ä¸­...</span></p>
            <p><strong>è¯†åˆ«çŠ¶æ€:</strong> <span id="recognitionStatus">æœªå¼€å§‹</span></p>
            <p><strong>é”™è¯¯è®¡æ•°:</strong> <span id="errorCount">0</span></p>
        </div>
    </div>

    <script>
        let isTesting = false;
        let errorCount = 0;
        let mediaRecorder = null;
        let stream = null;

        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            logElement.textContent += logEntry;
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(message);
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        function getSupportedMimeType() {
            const types = [
                'audio/wav',
                'audio/mp4',
                'audio/ogg;codecs=opus',
                'audio/webm',
                'audio/webm;codecs=opus'
            ];
            
            for (const type of types) {
                if (MediaRecorder.isTypeSupported(type)) {
                    log(`âœ… æ”¯æŒçš„éŸ³é¢‘æ ¼å¼: ${type}`);
                    document.getElementById('mimeType').textContent = type;
                    return type;
                }
            }
            
            log('âš ï¸ ä½¿ç”¨é»˜è®¤æ ¼å¼: audio/wav');
            document.getElementById('mimeType').textContent = 'audio/wav (é»˜è®¤)';
            return 'audio/wav';
        }

        async function testVoiceRecognition() {
            if (isTesting) return;
            
            isTesting = true;
            errorCount = 0;
            document.getElementById('testBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('errorCount').textContent = '0';
            
            try {
                updateStatus('ğŸ¤ æ­£åœ¨å¯åŠ¨è¯­éŸ³è¯†åˆ«æµ‹è¯•...', 'info');
                log('ğŸš€ å¼€å§‹è¯­éŸ³è¯†åˆ«æµ‹è¯•');
                
                // æ£€æµ‹éŸ³é¢‘æ ¼å¼æ”¯æŒ
                const mimeType = getSupportedMimeType();
                
                // è·å–éº¦å…‹é£æƒé™
                log('ğŸ™ï¸ è¯·æ±‚éº¦å…‹é£æƒé™...');
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        sampleRate: 48000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                log('âœ… éº¦å…‹é£æƒé™è·å–æˆåŠŸ');
                updateStatus('ğŸ™ï¸ éº¦å…‹é£å·²æ¿€æ´» - è¯·è¯´è¯æµ‹è¯•', 'success');
                document.getElementById('recognitionStatus').textContent = 'å½•éŸ³ä¸­';
                
                // è®¾ç½®å½•éŸ³å™¨
                mediaRecorder = new MediaRecorder(stream, { mimeType });
                let audioChunks = [];
                
                mediaRecorder.ondataavailable = async (event) => {
                    if (event.data.size > 0) {
                        log(`ğŸ“¦ æ”¶åˆ°éŸ³é¢‘æ•°æ®: ${event.data.size} bytes`);
                        audioChunks.push(event.data);
                        
                        // æµ‹è¯•éŸ³é¢‘è½¬æ¢ - æ”¶é›†æ›´å¤šå—ç¡®ä¿éŸ³é¢‘è´¨é‡
                        if (audioChunks.length >= 2) {
                            const totalSize = audioChunks.reduce((sum, chunk) => sum + chunk.size, 0);
                            if (totalSize >= 4096) { // è‡³å°‘4KB
                                const audioBlob = new Blob(audioChunks, { type: mimeType });
                                audioChunks = [];
                                
                                try {
                                    await testAudioConversion(audioBlob);
                                } catch (error) {
                                    errorCount++;
                                    document.getElementById('errorCount').textContent = errorCount.toString();
                                    log(`âŒ éŸ³é¢‘å¤„ç†é”™è¯¯: ${error.message}`, 'error');
                                }
                            }
                        }
                    }
                };
                
                mediaRecorder.onerror = (event) => {
                    errorCount++;
                    document.getElementById('errorCount').textContent = errorCount.toString();
                    log(`âŒ å½•éŸ³å™¨é”™è¯¯: ${event.error}`, 'error');
                };
                
                // å¼€å§‹å½•éŸ³
                mediaRecorder.start(3000); // æ¯3ç§’ä¸€ä¸ªå—
                log('ğŸµ å½•éŸ³å·²å¼€å§‹ï¼Œæ¯3ç§’å¤„ç†ä¸€æ¬¡éŸ³é¢‘æ•°æ®');
                
            } catch (error) {
                errorCount++;
                document.getElementById('errorCount').textContent = errorCount.toString();
                log(`âŒ æµ‹è¯•å¯åŠ¨å¤±è´¥: ${error.message}`, 'error');
                updateStatus('âŒ æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
                stopTest();
            }
        }

        async function testAudioConversion(audioBlob) {
            log(`ğŸ”§ æµ‹è¯•éŸ³é¢‘è½¬æ¢ï¼Œè¾“å…¥å¤§å°: ${audioBlob.size} bytes`);
            
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            try {
                const arrayBuffer = await audioBlob.arrayBuffer();
                log(`ğŸ“Š è¯»å–éŸ³é¢‘æ•°æ®: ${arrayBuffer.byteLength} bytes`);
                
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
                log(`âœ… éŸ³é¢‘è§£ç æˆåŠŸ: é‡‡æ ·ç‡=${audioBuffer.sampleRate}, å£°é“=${audioBuffer.numberOfChannels}, æ—¶é•¿=${audioBuffer.duration.toFixed(3)}s`);
                
                // æ¨¡æ‹Ÿé‡é‡‡æ ·
                const targetSampleRate = 16000;
                const length = Math.floor(audioBuffer.length * targetSampleRate / audioBuffer.sampleRate);
                const offlineContext = new OfflineAudioContext(1, length, targetSampleRate);
                
                const source = offlineContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(offlineContext.destination);
                source.start();
                
                const resampledBuffer = await offlineContext.startRendering();
                log(`ğŸ”„ é‡é‡‡æ ·å®Œæˆ: æ–°é•¿åº¦=${resampledBuffer.length}`);
                
                // è½¬æ¢ä¸ºPCM
                const samples = resampledBuffer.getChannelData(0);
                const int16Array = new Int16Array(samples.length);
                for (let i = 0; i < samples.length; i++) {
                    const s = Math.max(-1, Math.min(1, samples[i]));
                    int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                }
                
                log(`âœ… PCMè½¬æ¢å®Œæˆ: ${int16Array.buffer.byteLength} bytes`);
                updateStatus('âœ… éŸ³é¢‘å¤„ç†æ­£å¸¸ - ä¿®å¤ç”Ÿæ•ˆ!', 'success');
                
            } finally {
                audioContext.close();
            }
        }

        function stopTest() {
            isTesting = false;
            document.getElementById('testBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('recognitionStatus').textContent = 'å·²åœæ­¢';
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            log('ğŸ›‘ æµ‹è¯•å·²åœæ­¢');
            updateStatus('æµ‹è¯•å·²åœæ­¢', 'info');
        }

        function clearLog() {
            document.getElementById('log').textContent = '';
            log('ğŸ“‹ æ—¥å¿—å·²æ¸…é™¤');
        }

        // é¡µé¢åŠ è½½æ—¶æ£€æµ‹æ”¯æŒ
        window.onload = function() {
            getSupportedMimeType();
            log('ğŸ”§ é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡å¼€å§‹æµ‹è¯•');
        };
    </script>
</body>
</html> 